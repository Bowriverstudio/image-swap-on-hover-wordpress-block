{"version":3,"sources":["@wordpress/block-library/src/columns/utils.js"],"names":["findIndex","sumBy","merge","mapValues","toWidthPrecision","value","Number","isFinite","parseFloat","toFixed","undefined","getAdjacentBlocks","blocks","clientId","index","isLastBlock","length","slice","getEffectiveColumnWidth","block","totalBlockCount","attributes","width","getTotalColumnsWidth","getColumnWidths","reduce","accumulator","Object","assign","getRedistributedColumnWidths","availableWidth","totalWidth","difference","adjustment","hasExplicitColumnWidths","some","getMappedColumnWidths","widths","map"],"mappings":";;AAAA;;;AAGA,SAASA,SAAT,EAAoBC,KAApB,EAA2BC,KAA3B,EAAkCC,SAAlC,QAAmD,QAAnD;AAEA;;;;;;;;;AAQA,OAAO,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAEC,KAAF;AAAA,SAC/BC,MAAM,CAACC,QAAP,CAAiBF,KAAjB,IAA2BG,UAAU,CAAEH,KAAK,CAACI,OAAN,CAAe,CAAf,CAAF,CAArC,GAA8DC,SAD/B;AAAA,CAAzB;AAGP;;;;;;;;;;;;AAWA,OAAO,SAASC,iBAAT,CAA4BC,MAA5B,EAAoCC,QAApC,EAA+C;AACrD,MAAMC,KAAK,GAAGd,SAAS,CAAEY,MAAF,EAAU;AAAEC,IAAAA,QAAQ,EAARA;AAAF,GAAV,CAAvB;AACA,MAAME,WAAW,GAAGD,KAAK,KAAKF,MAAM,CAACI,MAAP,GAAgB,CAA9C;AAEA,SAAOD,WAAW,GAAGH,MAAM,CAACK,KAAP,CAAc,CAAd,EAAiBH,KAAjB,CAAH,GAA8BF,MAAM,CAACK,KAAP,CAAcH,KAAK,GAAG,CAAtB,CAAhD;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASI,uBAAT,CAAkCC,KAAlC,EAAyCC,eAAzC,EAA2D;AAAA,8BACvBD,KAAK,CAACE,UADiB,CACzDC,KADyD;AAAA,MACzDA,KADyD,sCACjD,MAAMF,eAD2C;AAEjE,SAAOhB,gBAAgB,CAAEkB,KAAF,CAAvB;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASC,oBAAT,CACNX,MADM,EAGL;AAAA,MADDQ,eACC,uEADiBR,MAAM,CAACI,MACxB;AACD,SAAOf,KAAK,CAAEW,MAAF,EAAU,UAAEO,KAAF;AAAA,WACrBD,uBAAuB,CAAEC,KAAF,EAASC,eAAT,CADF;AAAA,GAAV,CAAZ;AAGA;AAED;;;;;;;;;;AASA,OAAO,SAASI,eAAT,CAA0BZ,MAA1B,EAAoE;AAAA,MAAlCQ,eAAkC,uEAAhBR,MAAM,CAACI,MAAS;AAC1E,SAAOJ,MAAM,CAACa,MAAP,CAAe,UAAEC,WAAF,EAAeP,KAAf,EAA0B;AAC/C,QAAMG,KAAK,GAAGJ,uBAAuB,CAAEC,KAAF,EAASC,eAAT,CAArC;AACA,WAAOO,MAAM,CAACC,MAAP,CAAeF,WAAf,sBAAgCP,KAAK,CAACN,QAAtC,EAAkDS,KAAlD,EAAP;AACA,GAHM,EAGJ,EAHI,CAAP;AAIA;AAED;;;;;;;;;;;;;AAYA,OAAO,SAASO,4BAAT,CACNjB,MADM,EAENkB,cAFM,EAIL;AAAA,MADDV,eACC,uEADiBR,MAAM,CAACI,MACxB;AACD,MAAMe,UAAU,GAAGR,oBAAoB,CAAEX,MAAF,EAAUQ,eAAV,CAAvC;AACA,MAAMY,UAAU,GAAGF,cAAc,GAAGC,UAApC;AACA,MAAME,UAAU,GAAGD,UAAU,GAAGpB,MAAM,CAACI,MAAvC;AAEA,SAAOb,SAAS,CAAEqB,eAAe,CAAEZ,MAAF,EAAUQ,eAAV,CAAjB,EAA8C,UAAEE,KAAF;AAAA,WAC7DlB,gBAAgB,CAAEkB,KAAK,GAAGW,UAAV,CAD6C;AAAA,GAA9C,CAAhB;AAGA;AAED;;;;;;;;;AAQA,OAAO,SAASC,uBAAT,CAAkCtB,MAAlC,EAA2C;AACjD,SAAOA,MAAM,CAACuB,IAAP,CAAa,UAAEhB,KAAF;AAAA,WACnBb,MAAM,CAACC,QAAP,CAAiBY,KAAK,CAACE,UAAN,CAAiBC,KAAlC,CADmB;AAAA,GAAb,CAAP;AAGA;AAED;;;;;;;;;;AASA,OAAO,SAASc,qBAAT,CAAgCxB,MAAhC,EAAwCyB,MAAxC,EAAiD;AACvD,SAAOzB,MAAM,CAAC0B,GAAP,CAAY,UAAEnB,KAAF;AAAA,WAClBjB,KAAK,CAAE,EAAF,EAAMiB,KAAN,EAAa;AACjBE,MAAAA,UAAU,EAAE;AACXC,QAAAA,KAAK,EAAEe,MAAM,CAAElB,KAAK,CAACN,QAAR;AADF;AADK,KAAb,CADa;AAAA,GAAZ,CAAP;AAOA","sourcesContent":["/**\n * External dependencies\n */\nimport { findIndex, sumBy, merge, mapValues } from 'lodash';\n\n/**\n * Returns a column width attribute value rounded to standard precision.\n * Returns `undefined` if the value is not a valid finite number.\n *\n * @param {?number} value Raw value.\n *\n * @return {number} Value rounded to standard precision.\n */\nexport const toWidthPrecision = ( value ) =>\n\tNumber.isFinite( value ) ? parseFloat( value.toFixed( 2 ) ) : undefined;\n\n/**\n * Returns the considered adjacent to that of the specified `clientId` for\n * resizing consideration. Adjacent blocks are those occurring after, except\n * when the given block is the last block in the set. For the last block, the\n * behavior is reversed.\n *\n * @param {WPBlock[]} blocks   Block objects.\n * @param {string}    clientId Client ID to consider for adjacent blocks.\n *\n * @return {WPBlock[]} Adjacent block objects.\n */\nexport function getAdjacentBlocks( blocks, clientId ) {\n\tconst index = findIndex( blocks, { clientId } );\n\tconst isLastBlock = index === blocks.length - 1;\n\n\treturn isLastBlock ? blocks.slice( 0, index ) : blocks.slice( index + 1 );\n}\n\n/**\n * Returns an effective width for a given block. An effective width is equal to\n * its attribute value if set, or a computed value assuming equal distribution.\n *\n * @param {WPBlock} block           Block object.\n * @param {number}  totalBlockCount Total number of blocks in Columns.\n *\n * @return {number} Effective column width.\n */\nexport function getEffectiveColumnWidth( block, totalBlockCount ) {\n\tconst { width = 100 / totalBlockCount } = block.attributes;\n\treturn toWidthPrecision( width );\n}\n\n/**\n * Returns the total width occupied by the given set of column blocks.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {number} Total width occupied by blocks.\n */\nexport function getTotalColumnsWidth(\n\tblocks,\n\ttotalBlockCount = blocks.length\n) {\n\treturn sumBy( blocks, ( block ) =>\n\t\tgetEffectiveColumnWidth( block, totalBlockCount )\n\t);\n}\n\n/**\n * Returns an object of `clientId` → `width` of effective column widths.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {Object<string,number>} Column widths.\n */\nexport function getColumnWidths( blocks, totalBlockCount = blocks.length ) {\n\treturn blocks.reduce( ( accumulator, block ) => {\n\t\tconst width = getEffectiveColumnWidth( block, totalBlockCount );\n\t\treturn Object.assign( accumulator, { [ block.clientId ]: width } );\n\t}, {} );\n}\n\n/**\n * Returns an object of `clientId` → `width` of column widths as redistributed\n * proportional to their current widths, constrained or expanded to fit within\n * the given available width.\n *\n * @param {WPBlock[]} blocks          Block objects.\n * @param {number}    availableWidth  Maximum width to fit within.\n * @param {?number}   totalBlockCount Total number of blocks in Columns.\n *                                    Defaults to number of blocks passed.\n *\n * @return {Object<string,number>} Redistributed column widths.\n */\nexport function getRedistributedColumnWidths(\n\tblocks,\n\tavailableWidth,\n\ttotalBlockCount = blocks.length\n) {\n\tconst totalWidth = getTotalColumnsWidth( blocks, totalBlockCount );\n\tconst difference = availableWidth - totalWidth;\n\tconst adjustment = difference / blocks.length;\n\n\treturn mapValues( getColumnWidths( blocks, totalBlockCount ), ( width ) =>\n\t\ttoWidthPrecision( width + adjustment )\n\t);\n}\n\n/**\n * Returns true if column blocks within the provided set are assigned with\n * explicit widths, or false otherwise.\n *\n * @param {WPBlock[]} blocks Block objects.\n *\n * @return {boolean} Whether columns have explicit widths.\n */\nexport function hasExplicitColumnWidths( blocks ) {\n\treturn blocks.some( ( block ) =>\n\t\tNumber.isFinite( block.attributes.width )\n\t);\n}\n\n/**\n * Returns a copy of the given set of blocks with new widths assigned from the\n * provided object of redistributed column widths.\n *\n * @param {WPBlock[]}             blocks Block objects.\n * @param {Object<string,number>} widths Redistributed column widths.\n *\n * @return {WPBlock[]} blocks Mapped block objects.\n */\nexport function getMappedColumnWidths( blocks, widths ) {\n\treturn blocks.map( ( block ) =>\n\t\tmerge( {}, block, {\n\t\t\tattributes: {\n\t\t\t\twidth: widths[ block.clientId ],\n\t\t\t},\n\t\t} )\n\t);\n}\n"]}