import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import classnames from 'classnames';
import FastAverageColor from 'fast-average-color';
import tinycolor from 'tinycolor2';
/**
 * WordPress dependencies
 */

import { useEffect, useRef, useState } from '@wordpress/element';
import { BaseControl, Button, FocalPointPicker, PanelBody, PanelRow, RangeControl, ResizableBox, ToggleControl, withNotices } from '@wordpress/components';
import { compose, withInstanceId } from '@wordpress/compose';
import { BlockControls, BlockIcon, InnerBlocks, InspectorControls, MediaPlaceholder, MediaReplaceFlow, withColors, ColorPalette, __experimentalUseGradient, __experimentalPanelColorGradientSettings as PanelColorGradientSettings } from '@wordpress/block-editor';
import { __ } from '@wordpress/i18n';
import { withDispatch } from '@wordpress/data';
import { cover as icon } from '@wordpress/icons';
/**
 * Internal dependencies
 */

import { IMAGE_BACKGROUND_TYPE, VIDEO_BACKGROUND_TYPE, COVER_MIN_HEIGHT, backgroundImageStyles, dimRatioToClass } from './shared';
/**
 * Module Constants
 */

var ALLOWED_MEDIA_TYPES = ['image', 'video'];
var INNER_BLOCKS_TEMPLATE = [['core/paragraph', {
  align: 'center',
  fontSize: 'large',
  placeholder: __('Write titleâ€¦')
}]];

function retrieveFastAverageColor() {
  if (!retrieveFastAverageColor.fastAverageColor) {
    retrieveFastAverageColor.fastAverageColor = new FastAverageColor();
  }

  return retrieveFastAverageColor.fastAverageColor;
}

var CoverHeightInput = withInstanceId(function (_ref) {
  var _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      instanceId = _ref.instanceId,
      _onChange = _ref.onChange;

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      temporaryInput = _useState2[0],
      setTemporaryInput = _useState2[1];

  var inputId = "block-cover-height-input-".concat(instanceId);
  return createElement(BaseControl, {
    label: __('Minimum height in pixels'),
    id: inputId
  }, createElement("input", {
    type: "number",
    id: inputId,
    onChange: function onChange(event) {
      var unprocessedValue = event.target.value;
      var inputValue = unprocessedValue !== '' ? parseInt(event.target.value, 10) : undefined;

      if ((isNaN(inputValue) || inputValue < COVER_MIN_HEIGHT) && inputValue !== undefined) {
        setTemporaryInput(event.target.value);
        return;
      }

      setTemporaryInput(null);

      _onChange(inputValue);
    },
    onBlur: function onBlur() {
      if (temporaryInput !== null) {
        setTemporaryInput(null);
      }
    },
    value: temporaryInput !== null ? temporaryInput : value,
    min: COVER_MIN_HEIGHT,
    step: "1"
  }));
});
var RESIZABLE_BOX_ENABLE_OPTION = {
  top: false,
  right: false,
  bottom: true,
  left: false,
  topRight: false,
  bottomRight: false,
  bottomLeft: false,
  topLeft: false
};

function ResizableCover(_ref2) {
  var className = _ref2.className,
      children = _ref2.children,
      _onResizeStart = _ref2.onResizeStart,
      _onResize = _ref2.onResize,
      _onResizeStop = _ref2.onResizeStop;

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isResizing = _useState4[0],
      setIsResizing = _useState4[1];

  return createElement(ResizableBox, {
    className: classnames(className, {
      'is-resizing': isResizing
    }),
    enable: RESIZABLE_BOX_ENABLE_OPTION,
    onResizeStart: function onResizeStart(event, direction, elt) {
      _onResizeStart(elt.clientHeight);

      _onResize(elt.clientHeight);
    },
    onResize: function onResize(event, direction, elt) {
      _onResize(elt.clientHeight);

      if (!isResizing) {
        setIsResizing(true);
      }
    },
    onResizeStop: function onResizeStop(event, direction, elt) {
      _onResizeStop(elt.clientHeight);

      setIsResizing(false);
    },
    minHeight: COVER_MIN_HEIGHT
  }, children);
}

function onCoverSelectMedia(setAttributes) {
  return function (media) {
    if (!media || !media.url) {
      setAttributes({
        url: undefined,
        id: undefined
      });
      return;
    }

    var mediaType; // for media selections originated from a file upload.

    if (media.media_type) {
      if (media.media_type === IMAGE_BACKGROUND_TYPE) {
        mediaType = IMAGE_BACKGROUND_TYPE;
      } else {
        // only images and videos are accepted so if the media_type is not an image we can assume it is a video.
        // Videos contain the media type of 'file' in the object returned from the rest api.
        mediaType = VIDEO_BACKGROUND_TYPE;
      }
    } else {
      // for media selections originated from existing files in the media library.
      if (media.type !== IMAGE_BACKGROUND_TYPE && media.type !== VIDEO_BACKGROUND_TYPE) {
        return;
      }

      mediaType = media.type;
    }

    setAttributes(_objectSpread({
      url: media.url,
      id: media.id,
      backgroundType: mediaType
    }, mediaType === VIDEO_BACKGROUND_TYPE ? {
      focalPoint: undefined,
      hasParallax: undefined
    } : {}));
  };
}
/**
 * useCoverIsDark is a hook that returns a boolean variable specifying if the cover
 * background is dark or not.
 *
 * @param {?string} url          Url of the media background.
 * @param {?number} dimRatio     Transparency of the overlay color. If an image and
 *                               color are set, dimRatio is used to decide what is used
 *                               for background darkness checking purposes.
 * @param {?string} overlayColor String containing the overlay color value if one exists.
 * @param {?Object} elementRef   If a media background is set, elementRef should contain a reference to a
 *                               dom element that renders that media.
 *
 * @return {boolean} True if the cover background is considered "dark" and false otherwise.
 */


function useCoverIsDark(url) {
  var dimRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;
  var overlayColor = arguments.length > 2 ? arguments[2] : undefined;
  var elementRef = arguments.length > 3 ? arguments[3] : undefined;

  var _useState5 = useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      isDark = _useState6[0],
      setIsDark = _useState6[1];

  useEffect(function () {
    // If opacity is lower than 50 the dominant color is the image or video color,
    // so use that color for the dark mode computation.
    if (url && dimRatio <= 50 && elementRef.current) {
      retrieveFastAverageColor().getColorAsync(elementRef.current, function (color) {
        setIsDark(color.isDark);
      });
    }
  }, [url, url && dimRatio <= 50 && elementRef.current, setIsDark]);
  useEffect(function () {
    // If opacity is greater than 50 the dominant color is the overlay color,
    // so use that color for the dark mode computation.
    if (dimRatio > 50 || !url) {
      if (!overlayColor) {
        // If no overlay color exists the overlay color is black (isDark )
        setIsDark(true);
        return;
      }

      setIsDark(tinycolor(overlayColor).isDark());
    }
  }, [overlayColor, dimRatio > 50 || !url, setIsDark]);
  useEffect(function () {
    if (!url && !overlayColor) {
      // Reset isDark
      setIsDark(false);
    }
  }, [!url && !overlayColor, setIsDark]);
  return isDark;
}

function CoverEdit(_ref3) {
  var _classnames;

  var attributes = _ref3.attributes,
      setAttributes = _ref3.setAttributes,
      isSelected = _ref3.isSelected,
      className = _ref3.className,
      noticeUI = _ref3.noticeUI,
      overlayColor = _ref3.overlayColor,
      setOverlayColor = _ref3.setOverlayColor,
      toggleSelection = _ref3.toggleSelection,
      noticeOperations = _ref3.noticeOperations;
  var backgroundType = attributes.backgroundType,
      dimRatio = attributes.dimRatio,
      focalPoint = attributes.focalPoint,
      hasParallax = attributes.hasParallax,
      minHeight = attributes.minHeight,
      url = attributes.url;

  var _experimentalUseGrad = __experimentalUseGradient(),
      gradientClass = _experimentalUseGrad.gradientClass,
      gradientValue = _experimentalUseGrad.gradientValue,
      setGradient = _experimentalUseGrad.setGradient;

  var onSelectMedia = onCoverSelectMedia(setAttributes);

  var toggleParallax = function toggleParallax() {
    setAttributes(_objectSpread({
      hasParallax: !hasParallax
    }, !hasParallax ? {
      focalPoint: undefined
    } : {}));
  };

  var isDarkElement = useRef();
  var isDark = useCoverIsDark(url, dimRatio, overlayColor.color, isDarkElement);

  var _useState7 = useState(null),
      _useState8 = _slicedToArray(_useState7, 2),
      temporaryMinHeight = _useState8[0],
      setTemporaryMinHeight = _useState8[1];

  var removeAllNotices = noticeOperations.removeAllNotices,
      createErrorNotice = noticeOperations.createErrorNotice;

  var style = _objectSpread({}, backgroundType === IMAGE_BACKGROUND_TYPE ? backgroundImageStyles(url) : {}, {
    backgroundColor: overlayColor.color,
    minHeight: temporaryMinHeight || minHeight
  });

  if (gradientValue && !url) {
    style.background = gradientValue;
  }

  if (focalPoint) {
    style.backgroundPosition = "".concat(focalPoint.x * 100, "% ").concat(focalPoint.y * 100, "%");
  }

  var hasBackground = !!(url || overlayColor.color || gradientValue);
  var controls = createElement(Fragment, null, createElement(BlockControls, null, hasBackground && createElement(MediaReplaceFlow, {
    mediaURL: url,
    allowedTypes: ALLOWED_MEDIA_TYPES,
    accept: "image/*,video/*",
    onSelect: onSelectMedia
  })), createElement(InspectorControls, null, !!url && createElement(PanelBody, {
    title: __('Media settings')
  }, IMAGE_BACKGROUND_TYPE === backgroundType && createElement(ToggleControl, {
    label: __('Fixed Background'),
    checked: hasParallax,
    onChange: toggleParallax
  }), IMAGE_BACKGROUND_TYPE === backgroundType && !hasParallax && createElement(FocalPointPicker, {
    label: __('Focal Point Picker'),
    url: url,
    value: focalPoint,
    onChange: function onChange(newFocalPoint) {
      return setAttributes({
        focalPoint: newFocalPoint
      });
    }
  }), VIDEO_BACKGROUND_TYPE === backgroundType && createElement("video", {
    autoPlay: true,
    muted: true,
    loop: true,
    src: url
  }), createElement(PanelRow, null, createElement(Button, {
    isSecondary: true,
    isSmall: true,
    className: "block-library-cover__reset-button",
    onClick: function onClick() {
      return setAttributes({
        url: undefined,
        id: undefined,
        backgroundType: undefined,
        dimRatio: undefined,
        focalPoint: undefined,
        hasParallax: undefined
      });
    }
  }, __('Clear Media')))), hasBackground && createElement(Fragment, null, createElement(PanelBody, {
    title: __('Dimensions')
  }, createElement(CoverHeightInput, {
    value: temporaryMinHeight || minHeight,
    onChange: function onChange(newMinHeight) {
      return setAttributes({
        minHeight: newMinHeight
      });
    }
  })), createElement(PanelColorGradientSettings, {
    title: __('Overlay'),
    initialOpen: true,
    settings: [{
      colorValue: overlayColor.color,
      gradientValue: gradientValue,
      onColorChange: setOverlayColor,
      onGradientChange: setGradient,
      label: __('Overlay')
    }]
  }, !!url && createElement(RangeControl, {
    label: __('Background Opacity'),
    value: dimRatio,
    onChange: function onChange(newDimRation) {
      return setAttributes({
        dimRatio: newDimRation
      });
    },
    min: 0,
    max: 100,
    step: 10,
    required: true
  })))));

  if (!hasBackground) {
    var placeholderIcon = createElement(BlockIcon, {
      icon: icon
    });

    var label = __('Cover');

    return createElement(Fragment, null, controls, createElement(MediaPlaceholder, {
      icon: placeholderIcon,
      className: className,
      labels: {
        title: label,
        instructions: __('Upload an image or video file, or pick one from your media library.')
      },
      onSelect: onSelectMedia,
      accept: "image/*,video/*",
      allowedTypes: ALLOWED_MEDIA_TYPES,
      notices: noticeUI,
      onError: function onError(message) {
        removeAllNotices();
        createErrorNotice(message);
      }
    }, createElement("div", {
      className: "wp-block-cover__placeholder-background-options"
    }, createElement(ColorPalette, {
      disableCustomColors: true,
      value: overlayColor.color,
      onChange: setOverlayColor,
      clearable: false
    }))));
  }

  var classes = classnames(className, dimRatioToClass(dimRatio), (_classnames = {
    'is-dark-theme': isDark,
    'has-background-dim': dimRatio !== 0,
    'has-parallax': hasParallax
  }, _defineProperty(_classnames, overlayColor.class, overlayColor.class), _defineProperty(_classnames, 'has-background-gradient', gradientValue), _defineProperty(_classnames, gradientClass, !url && gradientClass), _classnames));
  return createElement(Fragment, null, controls, createElement(ResizableCover, {
    className: classnames('block-library-cover__resize-container', {
      'is-selected': isSelected
    }),
    onResizeStart: function onResizeStart() {
      return toggleSelection(false);
    },
    onResize: setTemporaryMinHeight,
    onResizeStop: function onResizeStop(newMinHeight) {
      toggleSelection(true);
      setAttributes({
        minHeight: newMinHeight
      });
      setTemporaryMinHeight(null);
    }
  }, createElement("div", {
    "data-url": url,
    style: style,
    className: classes
  }, IMAGE_BACKGROUND_TYPE === backgroundType && // Used only to programmatically check if the image is dark or not
  createElement("img", {
    ref: isDarkElement,
    "aria-hidden": true,
    alt: "",
    style: {
      display: 'none'
    },
    src: url
  }), url && gradientValue && dimRatio !== 0 && createElement("span", {
    "aria-hidden": "true",
    className: classnames('wp-block-cover__gradient-background', gradientClass),
    style: {
      background: gradientValue
    }
  }), VIDEO_BACKGROUND_TYPE === backgroundType && createElement("video", {
    ref: isDarkElement,
    className: "wp-block-cover__video-background",
    autoPlay: true,
    muted: true,
    loop: true,
    src: url
  }), createElement("div", {
    className: "wp-block-cover__inner-container"
  }, createElement(InnerBlocks, {
    template: INNER_BLOCKS_TEMPLATE
  })))));
}

export default compose([withDispatch(function (dispatch) {
  var _dispatch = dispatch('core/block-editor'),
      toggleSelection = _dispatch.toggleSelection;

  return {
    toggleSelection: toggleSelection
  };
}), withColors({
  overlayColor: 'background-color'
}), withNotices, withInstanceId])(CoverEdit);
//# sourceMappingURL=edit.js.map