"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ImageEdit = exports.pickRelevantMediaFiles = void 0;

var _element = require("@wordpress/element");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _classnames2 = _interopRequireDefault(require("classnames"));

var _lodash = require("lodash");

var _blob = require("@wordpress/blob");

var _components = require("@wordpress/components");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _blockEditor = require("@wordpress/block-editor");

var _i18n = require("@wordpress/i18n");

var _url = require("@wordpress/url");

var _viewport = require("@wordpress/viewport");

var _icons = require("@wordpress/icons");

var _util = require("../embed/util");

var _imageSize = _interopRequireDefault(require("./image-size"));

var _constants = require("./constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var pickRelevantMediaFiles = function pickRelevantMediaFiles(image) {
  var imageProps = (0, _lodash.pick)(image, ['alt', 'id', 'link', 'caption']);
  imageProps.url = (0, _lodash.get)(image, ['sizes', 'large', 'url']) || (0, _lodash.get)(image, ['media_details', 'sizes', 'large', 'source_url']) || image.url;
  return imageProps;
};
/**
 * Is the URL a temporary blob URL? A blob URL is one that is used temporarily
 * while the image is being uploaded and will not have an id yet allocated.
 *
 * @param {number=} id The id of the image.
 * @param {string=} url The url of the image.
 *
 * @return {boolean} Is the URL a Blob URL
 */


exports.pickRelevantMediaFiles = pickRelevantMediaFiles;

var isTemporaryImage = function isTemporaryImage(id, url) {
  return !id && (0, _blob.isBlobURL)(url);
};
/**
 * Is the url for the image hosted externally. An externally hosted image has no id
 * and is not a blob url.
 *
 * @param {number=} id  The id of the image.
 * @param {string=} url The url of the image.
 *
 * @return {boolean} Is the url an externally hosted url?
 */


var isExternalImage = function isExternalImage(id, url) {
  return url && !id && !(0, _blob.isBlobURL)(url);
};

var ImageEdit =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(ImageEdit, _Component);

  function ImageEdit() {
    var _this;

    (0, _classCallCheck2.default)(this, ImageEdit);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ImageEdit).apply(this, arguments));
    _this.updateAlt = _this.updateAlt.bind((0, _assertThisInitialized2.default)(_this));
    _this.updateAlignment = _this.updateAlignment.bind((0, _assertThisInitialized2.default)(_this));
    _this.onFocusCaption = _this.onFocusCaption.bind((0, _assertThisInitialized2.default)(_this));
    _this.onImageClick = _this.onImageClick.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSelectImage = _this.onSelectImage.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSelectURL = _this.onSelectURL.bind((0, _assertThisInitialized2.default)(_this));
    _this.updateImage = _this.updateImage.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSetHref = _this.onSetHref.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSetTitle = _this.onSetTitle.bind((0, _assertThisInitialized2.default)(_this));
    _this.getFilename = _this.getFilename.bind((0, _assertThisInitialized2.default)(_this));
    _this.onUploadError = _this.onUploadError.bind((0, _assertThisInitialized2.default)(_this));
    _this.onImageError = _this.onImageError.bind((0, _assertThisInitialized2.default)(_this));
    _this.state = {
      captionFocused: false
    };
    return _this;
  }

  (0, _createClass2.default)(ImageEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var _this$props = this.props,
          attributes = _this$props.attributes,
          mediaUpload = _this$props.mediaUpload,
          noticeOperations = _this$props.noticeOperations;
      var id = attributes.id,
          _attributes$url = attributes.url,
          url = _attributes$url === void 0 ? '' : _attributes$url;

      if (isTemporaryImage(id, url)) {
        var file = (0, _blob.getBlobByURL)(url);

        if (file) {
          mediaUpload({
            filesList: [file],
            onFileChange: function onFileChange(_ref) {
              var _ref2 = (0, _slicedToArray2.default)(_ref, 1),
                  image = _ref2[0];

              _this2.onSelectImage(image);
            },
            allowedTypes: _constants.ALLOWED_MEDIA_TYPES,
            onError: function onError(message) {
              noticeOperations.createErrorNotice(message);
            }
          });
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _prevProps$attributes = prevProps.attributes,
          prevID = _prevProps$attributes.id,
          _prevProps$attributes2 = _prevProps$attributes.url,
          prevURL = _prevProps$attributes2 === void 0 ? '' : _prevProps$attributes2;
      var _this$props$attribute = this.props.attributes,
          id = _this$props$attribute.id,
          _this$props$attribute2 = _this$props$attribute.url,
          url = _this$props$attribute2 === void 0 ? '' : _this$props$attribute2;

      if (isTemporaryImage(prevID, prevURL) && !isTemporaryImage(id, url)) {
        (0, _blob.revokeBlobURL)(url);
      }

      if (!this.props.isSelected && prevProps.isSelected && this.state.captionFocused) {
        this.setState({
          captionFocused: false
        });
      }
    }
  }, {
    key: "onUploadError",
    value: function onUploadError(message) {
      var noticeOperations = this.props.noticeOperations;
      noticeOperations.removeAllNotices();
      noticeOperations.createErrorNotice(message);
    }
  }, {
    key: "onSelectImage",
    value: function onSelectImage(media) {
      if (!media || !media.url) {
        this.props.setAttributes({
          url: undefined,
          alt: undefined,
          id: undefined,
          title: undefined,
          caption: undefined
        });
        return;
      }

      var _this$props$attribute3 = this.props.attributes,
          id = _this$props$attribute3.id,
          url = _this$props$attribute3.url,
          alt = _this$props$attribute3.alt,
          caption = _this$props$attribute3.caption,
          linkDestination = _this$props$attribute3.linkDestination;
      var mediaAttributes = pickRelevantMediaFiles(media); // If the current image is temporary but an alt or caption text was meanwhile written by the user,
      // make sure the text is not overwritten.

      if (isTemporaryImage(id, url)) {
        if (alt) {
          mediaAttributes = (0, _lodash.omit)(mediaAttributes, ['alt']);
        }

        if (caption) {
          mediaAttributes = (0, _lodash.omit)(mediaAttributes, ['caption']);
        }
      }

      var additionalAttributes; // Reset the dimension attributes if changing to a different image.

      if (!media.id || media.id !== id) {
        additionalAttributes = {
          width: undefined,
          height: undefined,
          sizeSlug: _constants.DEFAULT_SIZE_SLUG
        };
      } else {
        // Keep the same url when selecting the same file, so "Image Size" option is not changed.
        additionalAttributes = {
          url: url
        };
      } // Check if the image is linked to it's media.


      if (linkDestination === _constants.LINK_DESTINATION_MEDIA) {
        // Update the media link.
        mediaAttributes.href = media.url;
      } // Check if the image is linked to the attachment page.


      if (linkDestination === _constants.LINK_DESTINATION_ATTACHMENT) {
        // Update the media link.
        mediaAttributes.href = media.link;
      }

      this.props.setAttributes(_objectSpread({}, mediaAttributes, {}, additionalAttributes));
    }
  }, {
    key: "onSelectURL",
    value: function onSelectURL(newURL) {
      var url = this.props.attributes.url;

      if (newURL !== url) {
        this.props.setAttributes({
          url: newURL,
          id: undefined,
          sizeSlug: _constants.DEFAULT_SIZE_SLUG
        });
      }
    }
  }, {
    key: "onImageError",
    value: function onImageError(url) {
      // Check if there's an embed block that handles this URL.
      var embedBlock = (0, _util.createUpgradedEmbedBlock)({
        attributes: {
          url: url
        }
      });

      if (undefined !== embedBlock) {
        this.props.onReplace(embedBlock);
      }
    }
  }, {
    key: "onSetHref",
    value: function onSetHref(props) {
      this.props.setAttributes(props);
    }
  }, {
    key: "onSetTitle",
    value: function onSetTitle(value) {
      // This is the HTML title attribute, separate from the media object title
      this.props.setAttributes({
        title: value
      });
    }
  }, {
    key: "onFocusCaption",
    value: function onFocusCaption() {
      if (!this.state.captionFocused) {
        this.setState({
          captionFocused: true
        });
      }
    }
  }, {
    key: "onImageClick",
    value: function onImageClick() {
      if (this.state.captionFocused) {
        this.setState({
          captionFocused: false
        });
      }
    }
  }, {
    key: "updateAlt",
    value: function updateAlt(newAlt) {
      this.props.setAttributes({
        alt: newAlt
      });
    }
  }, {
    key: "updateAlignment",
    value: function updateAlignment(nextAlign) {
      var extraUpdatedAttributes = ['wide', 'full'].indexOf(nextAlign) !== -1 ? {
        width: undefined,
        height: undefined
      } : {};
      this.props.setAttributes(_objectSpread({}, extraUpdatedAttributes, {
        align: nextAlign
      }));
    }
  }, {
    key: "updateImage",
    value: function updateImage(sizeSlug) {
      var image = this.props.image;
      var url = (0, _lodash.get)(image, ['media_details', 'sizes', sizeSlug, 'source_url']);

      if (!url) {
        return null;
      }

      this.props.setAttributes({
        url: url,
        width: undefined,
        height: undefined,
        sizeSlug: sizeSlug
      });
    }
  }, {
    key: "getFilename",
    value: function getFilename(url) {
      var path = (0, _url.getPath)(url);

      if (path) {
        return (0, _lodash.last)(path.split('/'));
      }
    }
  }, {
    key: "getImageSizeOptions",
    value: function getImageSizeOptions() {
      var _this$props2 = this.props,
          imageSizes = _this$props2.imageSizes,
          image = _this$props2.image;
      return (0, _lodash.map)((0, _lodash.filter)(imageSizes, function (_ref3) {
        var slug = _ref3.slug;
        return (0, _lodash.get)(image, ['media_details', 'sizes', slug, 'source_url']);
      }), function (_ref4) {
        var name = _ref4.name,
            slug = _ref4.slug;
        return {
          value: slug,
          label: name
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props3 = this.props,
          attributes = _this$props3.attributes,
          setAttributes = _this$props3.setAttributes,
          isLargeViewport = _this$props3.isLargeViewport,
          isSelected = _this$props3.isSelected,
          className = _this$props3.className,
          maxWidth = _this$props3.maxWidth,
          noticeUI = _this$props3.noticeUI,
          isRTL = _this$props3.isRTL,
          onResizeStart = _this$props3.onResizeStart,
          _onResizeStop = _this$props3.onResizeStop;
      var url = attributes.url,
          alt = attributes.alt,
          caption = attributes.caption,
          align = attributes.align,
          id = attributes.id,
          href = attributes.href,
          rel = attributes.rel,
          linkClass = attributes.linkClass,
          linkDestination = attributes.linkDestination,
          title = attributes.title,
          width = attributes.width,
          height = attributes.height,
          linkTarget = attributes.linkTarget,
          sizeSlug = attributes.sizeSlug;
      var isExternal = isExternalImage(id, url);
      var controls = (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_blockEditor.BlockAlignmentToolbar, {
        value: align,
        onChange: this.updateAlignment
      }), url && (0, _element.createElement)(_blockEditor.MediaReplaceFlow, {
        mediaURL: url,
        allowedTypes: _constants.ALLOWED_MEDIA_TYPES,
        accept: "image/*",
        onSelect: this.onSelectImage,
        onSelectURL: this.onSelectURL,
        onError: this.onUploadError
      }), url && (0, _element.createElement)(_components.ToolbarGroup, null, (0, _element.createElement)(_blockEditor.__experimentalImageURLInputUI, {
        url: href || '',
        onChangeUrl: this.onSetHref,
        linkDestination: linkDestination,
        mediaUrl: this.props.image && this.props.image.source_url,
        mediaLink: this.props.image && this.props.image.link,
        linkTarget: linkTarget,
        linkClass: linkClass,
        rel: rel
      })));
      var src = isExternal ? url : undefined;
      var labels = {
        title: !url ? (0, _i18n.__)('Image') : (0, _i18n.__)('Edit image'),
        instructions: (0, _i18n.__)('Upload an image file, pick one from your media library, or add one with a URL.')
      };
      var mediaPreview = !!url && (0, _element.createElement)("img", {
        alt: (0, _i18n.__)('Edit image'),
        title: (0, _i18n.__)('Edit image'),
        className: 'edit-image-preview',
        src: url
      });
      var mediaPlaceholder = (0, _element.createElement)(_blockEditor.MediaPlaceholder, {
        icon: (0, _element.createElement)(_blockEditor.BlockIcon, {
          icon: _icons.image
        }),
        className: className,
        labels: labels,
        onSelect: this.onSelectImage,
        onSelectURL: this.onSelectURL,
        notices: noticeUI,
        onError: this.onUploadError,
        accept: "image/*",
        allowedTypes: _constants.ALLOWED_MEDIA_TYPES,
        value: {
          id: id,
          src: src
        },
        mediaPreview: mediaPreview,
        disableMediaButtons: url
      });

      if (!url) {
        return (0, _element.createElement)(_element.Fragment, null, controls, mediaPlaceholder);
      }

      var classes = (0, _classnames2.default)(className, (0, _defineProperty2.default)({
        'is-transient': (0, _blob.isBlobURL)(url),
        'is-resized': !!width || !!height,
        'is-focused': isSelected
      }, "size-".concat(sizeSlug), sizeSlug));
      var isResizable = ['wide', 'full'].indexOf(align) === -1 && isLargeViewport;
      var imageSizeOptions = this.getImageSizeOptions();

      var getInspectorControls = function getInspectorControls(imageWidth, imageHeight) {
        return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_blockEditor.InspectorControls, null, (0, _element.createElement)(_components.PanelBody, {
          title: (0, _i18n.__)('Image settings')
        }, (0, _element.createElement)(_components.TextareaControl, {
          label: (0, _i18n.__)('Alt Text (Alternative Text)'),
          value: alt,
          onChange: _this3.updateAlt,
          help: (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.ExternalLink, {
            href: "https://www.w3.org/WAI/tutorials/images/decision-tree"
          }, (0, _i18n.__)('Describe the purpose of the image')), (0, _i18n.__)('Leave empty if the image is purely decorative.'))
        }), (0, _element.createElement)(_blockEditor.__experimentalImageSizeControl, {
          onChangeImage: _this3.updateImage,
          onChange: function onChange(value) {
            return setAttributes(value);
          },
          slug: sizeSlug,
          width: width,
          height: height,
          imageSizeOptions: imageSizeOptions,
          isResizable: isResizable,
          imageWidth: imageWidth,
          imageHeight: imageHeight
        }))), (0, _element.createElement)(_blockEditor.InspectorAdvancedControls, null, (0, _element.createElement)(_components.TextControl, {
          label: (0, _i18n.__)('Title Attribute'),
          value: title || '',
          onChange: _this3.onSetTitle,
          help: (0, _element.createElement)(_element.Fragment, null, (0, _i18n.__)('Describe the role of this image on the page.'), (0, _element.createElement)(_components.ExternalLink, {
            href: "https://www.w3.org/TR/html52/dom.html#the-title-attribute"
          }, (0, _i18n.__)('(Note: many devices and browsers do not display this text.)')))
        })));
      }; // Disable reason: Each block can be selected by clicking on it

      /* eslint-disable jsx-a11y/click-events-have-key-events */


      return (0, _element.createElement)(_element.Fragment, null, controls, (0, _element.createElement)("figure", {
        className: classes
      }, (0, _element.createElement)(_imageSize.default, {
        src: url,
        dirtynessTrigger: align
      }, function (sizes) {
        var imageWidthWithinContainer = sizes.imageWidthWithinContainer,
            imageHeightWithinContainer = sizes.imageHeightWithinContainer,
            imageWidth = sizes.imageWidth,
            imageHeight = sizes.imageHeight;

        var filename = _this3.getFilename(url);

        var defaultedAlt;

        if (alt) {
          defaultedAlt = alt;
        } else if (filename) {
          defaultedAlt = (0, _i18n.sprintf)((0, _i18n.__)('This image has an empty alt attribute; its file name is %s'), filename);
        } else {
          defaultedAlt = (0, _i18n.__)('This image has an empty alt attribute');
        }

        var img = // Disable reason: Image itself is not meant to be interactive, but
        // should direct focus to block.

        /* eslint-disable jsx-a11y/no-noninteractive-element-interactions */
        (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)("img", {
          src: url,
          alt: defaultedAlt,
          onClick: _this3.onImageClick,
          onError: function onError() {
            return _this3.onImageError(url);
          }
        }), (0, _blob.isBlobURL)(url) && (0, _element.createElement)(_components.Spinner, null))
        /* eslint-enable jsx-a11y/no-noninteractive-element-interactions */
        ;

        if (!isResizable || !imageWidthWithinContainer) {
          return (0, _element.createElement)(_element.Fragment, null, getInspectorControls(imageWidth, imageHeight), (0, _element.createElement)("div", {
            style: {
              width: width,
              height: height
            }
          }, img));
        }

        var currentWidth = width || imageWidthWithinContainer;
        var currentHeight = height || imageHeightWithinContainer;
        var ratio = imageWidth / imageHeight;
        var minWidth = imageWidth < imageHeight ? _constants.MIN_SIZE : _constants.MIN_SIZE * ratio;
        var minHeight = imageHeight < imageWidth ? _constants.MIN_SIZE : _constants.MIN_SIZE / ratio; // With the current implementation of ResizableBox, an image needs an explicit pixel value for the max-width.
        // In absence of being able to set the content-width, this max-width is currently dictated by the vanilla editor style.
        // The following variable adds a buffer to this vanilla style, so 3rd party themes have some wiggleroom.
        // This does, in most cases, allow you to scale the image beyond the width of the main column, though not infinitely.
        // @todo It would be good to revisit this once a content-width variable becomes available.

        var maxWidthBuffer = maxWidth * 2.5;
        var showRightHandle = false;
        var showLeftHandle = false;
        /* eslint-disable no-lonely-if */
        // See https://github.com/WordPress/gutenberg/issues/7584.

        if (align === 'center') {
          // When the image is centered, show both handles.
          showRightHandle = true;
          showLeftHandle = true;
        } else if (isRTL) {
          // In RTL mode the image is on the right by default.
          // Show the right handle and hide the left handle only when it is aligned left.
          // Otherwise always show the left handle.
          if (align === 'left') {
            showRightHandle = true;
          } else {
            showLeftHandle = true;
          }
        } else {
          // Show the left handle and hide the right handle only when the image is aligned right.
          // Otherwise always show the right handle.
          if (align === 'right') {
            showLeftHandle = true;
          } else {
            showRightHandle = true;
          }
        }
        /* eslint-enable no-lonely-if */


        return (0, _element.createElement)(_element.Fragment, null, getInspectorControls(imageWidth, imageHeight), (0, _element.createElement)(_components.ResizableBox, {
          size: {
            width: width,
            height: height
          },
          minWidth: minWidth,
          maxWidth: maxWidthBuffer,
          minHeight: minHeight,
          maxHeight: maxWidthBuffer / ratio,
          lockAspectRatio: true,
          enable: {
            top: false,
            right: showRightHandle,
            bottom: true,
            left: showLeftHandle
          },
          onResizeStart: onResizeStart,
          onResizeStop: function onResizeStop(event, direction, elt, delta) {
            _onResizeStop();

            setAttributes({
              width: parseInt(currentWidth + delta.width, 10),
              height: parseInt(currentHeight + delta.height, 10)
            });
          }
        }, img));
      }), (!_blockEditor.RichText.isEmpty(caption) || isSelected) && (0, _element.createElement)(_blockEditor.RichText, {
        tagName: "figcaption",
        placeholder: (0, _i18n.__)('Write caption…'),
        value: caption,
        unstableOnFocus: this.onFocusCaption,
        onChange: function onChange(value) {
          return setAttributes({
            caption: value
          });
        },
        isSelected: this.state.captionFocused,
        inlineToolbar: true
      })), mediaPlaceholder);
      /* eslint-enable jsx-a11y/click-events-have-key-events */
    }
  }]);
  return ImageEdit;
}(_element.Component);

exports.ImageEdit = ImageEdit;

var _default = (0, _compose.compose)([(0, _data.withDispatch)(function (dispatch) {
  var _dispatch = dispatch('core/block-editor'),
      toggleSelection = _dispatch.toggleSelection;

  return {
    onResizeStart: function onResizeStart() {
      return toggleSelection(false);
    },
    onResizeStop: function onResizeStop() {
      return toggleSelection(true);
    }
  };
}), (0, _data.withSelect)(function (select, props) {
  var _select = select('core'),
      getMedia = _select.getMedia;

  var _select2 = select('core/block-editor'),
      getSettings = _select2.getSettings;

  var id = props.attributes.id,
      isSelected = props.isSelected;

  var _getSettings = getSettings(),
      mediaUpload = _getSettings.mediaUpload,
      imageSizes = _getSettings.imageSizes,
      isRTL = _getSettings.isRTL,
      maxWidth = _getSettings.maxWidth;

  return {
    image: id && isSelected ? getMedia(id) : null,
    maxWidth: maxWidth,
    isRTL: isRTL,
    imageSizes: imageSizes,
    mediaUpload: mediaUpload
  };
}), (0, _viewport.withViewportMatch)({
  isLargeViewport: 'medium'
}), _components.withNotices])(ImageEdit);

exports.default = _default;
//# sourceMappingURL=edit.js.map