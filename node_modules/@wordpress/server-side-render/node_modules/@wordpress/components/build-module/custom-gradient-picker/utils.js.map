{"version":3,"sources":["@wordpress/components/src/custom-gradient-picker/utils.js"],"names":["findIndex","map","some","INSERT_POINT_WIDTH","MINIMUM_ABSOLUTE_LEFT_POSITION","MINIMUM_DISTANCE_BETWEEN_POINTS","serializeGradientColor","serializeGradientPosition","tinyColorRgbToGradientColorStop","r","g","b","a","type","value","getGradientWithColorStopAdded","gradientAST","relativePosition","rgbaColor","colorStop","length","colorStops","getGradientWithPositionAtIndexChanged","index","colorStopIndex","isControlPointOverlapping","position","initialIndex","initialPosition","parseInt","minPosition","Math","min","maxPosition","max","itemPosition","abs","getGradientWithPositionAtIndexSummed","valueToSum","currentPosition","newPosition","getGradientWithPositionAtIndexIncreased","getGradientWithPositionAtIndexDecreased","getGradientWithColorAtIndexChanged","getGradientWithColorAtPositionChanged","relativePositionValue","toString","getGradientWithControlPointRemoved","filter","elem","elemIndex","getHorizontalRelativeGradientPosition","mouseXCoordinate","containerElement","positionedElementWidth","getBoundingClientRect","x","width","absolutePositionValue","availableWidth","round","getMarkerPoints","color","positionValue"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { findIndex, map, some } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport {\n\tINSERT_POINT_WIDTH,\n\tMINIMUM_ABSOLUTE_LEFT_POSITION,\n\tMINIMUM_DISTANCE_BETWEEN_POINTS,\n} from './constants';\nimport {\n\tserializeGradientColor,\n\tserializeGradientPosition,\n} from './serializer';\n\nfunction tinyColorRgbToGradientColorStop( { r, g, b, a } ) {\n\tif ( a === 1 ) {\n\t\treturn {\n\t\t\ttype: 'rgb',\n\t\t\tvalue: [ r, g, b ],\n\t\t};\n\t}\n\treturn {\n\t\ttype: 'rgba',\n\t\tvalue: [ r, g, b, a ],\n\t};\n}\n\nexport function getGradientWithColorStopAdded(\n\tgradientAST,\n\trelativePosition,\n\trgbaColor\n) {\n\tconst colorStop = tinyColorRgbToGradientColorStop( rgbaColor );\n\tcolorStop.length = {\n\t\ttype: '%',\n\t\tvalue: relativePosition,\n\t};\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: [ ...gradientAST.colorStops, colorStop ],\n\t};\n}\n\nexport function getGradientWithPositionAtIndexChanged(\n\tgradientAST,\n\tindex,\n\trelativePosition\n) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.map(\n\t\t\t( colorStop, colorStopIndex ) => {\n\t\t\t\tif ( colorStopIndex !== index ) {\n\t\t\t\t\treturn colorStop;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...colorStop,\n\t\t\t\t\tlength: {\n\t\t\t\t\t\t...colorStop.length,\n\t\t\t\t\t\tvalue: relativePosition,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t),\n\t};\n}\n\nexport function isControlPointOverlapping(\n\tgradientAST,\n\tposition,\n\tinitialIndex\n) {\n\tconst initialPosition = parseInt(\n\t\tgradientAST.colorStops[ initialIndex ].length.value\n\t);\n\tconst minPosition = Math.min( initialPosition, position );\n\tconst maxPosition = Math.max( initialPosition, position );\n\n\treturn some( gradientAST.colorStops, ( { length }, index ) => {\n\t\tconst itemPosition = parseInt( length.value );\n\t\treturn (\n\t\t\tindex !== initialIndex &&\n\t\t\t( Math.abs( itemPosition - position ) <\n\t\t\t\tMINIMUM_DISTANCE_BETWEEN_POINTS ||\n\t\t\t\t( minPosition < itemPosition && itemPosition < maxPosition ) )\n\t\t);\n\t} );\n}\n\nfunction getGradientWithPositionAtIndexSummed(\n\tgradientAST,\n\tindex,\n\tvalueToSum\n) {\n\tconst currentPosition = gradientAST.colorStops[ index ].length.value;\n\tconst newPosition = Math.max(\n\t\t0,\n\t\tMath.min( 100, parseInt( currentPosition ) + valueToSum )\n\t);\n\tif ( isControlPointOverlapping( gradientAST, newPosition, index ) ) {\n\t\treturn gradientAST;\n\t}\n\treturn getGradientWithPositionAtIndexChanged(\n\t\tgradientAST,\n\t\tindex,\n\t\tnewPosition\n\t);\n}\n\nexport function getGradientWithPositionAtIndexIncreased( gradientAST, index ) {\n\treturn getGradientWithPositionAtIndexSummed(\n\t\tgradientAST,\n\t\tindex,\n\t\tMINIMUM_DISTANCE_BETWEEN_POINTS\n\t);\n}\n\nexport function getGradientWithPositionAtIndexDecreased( gradientAST, index ) {\n\treturn getGradientWithPositionAtIndexSummed(\n\t\tgradientAST,\n\t\tindex,\n\t\t-MINIMUM_DISTANCE_BETWEEN_POINTS\n\t);\n}\n\nexport function getGradientWithColorAtIndexChanged(\n\tgradientAST,\n\tindex,\n\trgbaColor\n) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.map(\n\t\t\t( colorStop, colorStopIndex ) => {\n\t\t\t\tif ( colorStopIndex !== index ) {\n\t\t\t\t\treturn colorStop;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...colorStop,\n\t\t\t\t\t...tinyColorRgbToGradientColorStop( rgbaColor ),\n\t\t\t\t};\n\t\t\t}\n\t\t),\n\t};\n}\n\nexport function getGradientWithColorAtPositionChanged(\n\tgradientAST,\n\trelativePositionValue,\n\trgbaColor\n) {\n\tconst index = findIndex( gradientAST.colorStops, ( colorStop ) => {\n\t\treturn (\n\t\t\tcolorStop &&\n\t\t\tcolorStop.length &&\n\t\t\tcolorStop.length.type === '%' &&\n\t\t\tcolorStop.length.value === relativePositionValue.toString()\n\t\t);\n\t} );\n\treturn getGradientWithColorAtIndexChanged( gradientAST, index, rgbaColor );\n}\n\nexport function getGradientWithControlPointRemoved( gradientAST, index ) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.filter( ( elem, elemIndex ) => {\n\t\t\treturn elemIndex !== index;\n\t\t} ),\n\t};\n}\n\nexport function getHorizontalRelativeGradientPosition(\n\tmouseXCoordinate,\n\tcontainerElement,\n\tpositionedElementWidth\n) {\n\tif ( ! containerElement ) {\n\t\treturn;\n\t}\n\tconst { x, width } = containerElement.getBoundingClientRect();\n\tconst absolutePositionValue =\n\t\tmouseXCoordinate -\n\t\tx -\n\t\tMINIMUM_ABSOLUTE_LEFT_POSITION -\n\t\tpositionedElementWidth / 2;\n\tconst availableWidth =\n\t\twidth - MINIMUM_ABSOLUTE_LEFT_POSITION - INSERT_POINT_WIDTH;\n\treturn Math.round(\n\t\tMath.min(\n\t\t\tMath.max( ( absolutePositionValue * 100 ) / availableWidth, 0 ),\n\t\t\t100\n\t\t)\n\t);\n}\n\n/**\n * Returns the marker points from a gradient AST.\n *\n * @param {Object} gradientAST An object representing the gradient AST.\n *\n * @return {Array.<{color: string, position: string, positionValue: number}>}\n *         An array of markerPoint objects.\n *         color:         A string with the color code ready to be used in css style e.g: \"rgba( 1, 2 , 3, 0.5)\".\n *         position:      A string with the position ready to be used in css style e.g: \"70%\".\n *         positionValue: A number with the relative position value e.g: 70.\n */\nexport function getMarkerPoints( gradientAST ) {\n\tif ( ! gradientAST ) {\n\t\treturn [];\n\t}\n\treturn map( gradientAST.colorStops, ( colorStop ) => {\n\t\tif (\n\t\t\t! colorStop ||\n\t\t\t! colorStop.length ||\n\t\t\tcolorStop.length.type !== '%'\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tcolor: serializeGradientColor( colorStop ),\n\t\t\tposition: serializeGradientPosition( colorStop.length ),\n\t\t\tpositionValue: parseInt( colorStop.length.value ),\n\t\t};\n\t} );\n}\n"]}