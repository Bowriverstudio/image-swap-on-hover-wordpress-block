{"version":3,"sources":["@wordpress/components/src/custom-gradient-picker/utils.js"],"names":["findIndex","map","some","INSERT_POINT_WIDTH","MINIMUM_ABSOLUTE_LEFT_POSITION","MINIMUM_DISTANCE_BETWEEN_POINTS","serializeGradientColor","serializeGradientPosition","tinyColorRgbToGradientColorStop","r","g","b","a","type","value","getGradientWithColorStopAdded","gradientAST","relativePosition","rgbaColor","colorStop","length","colorStops","getGradientWithPositionAtIndexChanged","index","colorStopIndex","isControlPointOverlapping","position","initialIndex","initialPosition","parseInt","minPosition","Math","min","maxPosition","max","itemPosition","abs","getGradientWithPositionAtIndexSummed","valueToSum","currentPosition","newPosition","getGradientWithPositionAtIndexIncreased","getGradientWithPositionAtIndexDecreased","getGradientWithColorAtIndexChanged","getGradientWithColorAtPositionChanged","relativePositionValue","toString","getGradientWithControlPointRemoved","filter","elem","elemIndex","getHorizontalRelativeGradientPosition","mouseXCoordinate","containerElement","positionedElementWidth","getBoundingClientRect","x","width","absolutePositionValue","availableWidth","round","getMarkerPoints","color","positionValue"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { findIndex, map, some } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport {\n\tINSERT_POINT_WIDTH,\n\tMINIMUM_ABSOLUTE_LEFT_POSITION,\n\tMINIMUM_DISTANCE_BETWEEN_POINTS,\n} from './constants';\nimport {\n\tserializeGradientColor,\n\tserializeGradientPosition,\n} from './serializer';\n\nfunction tinyColorRgbToGradientColorStop( { r, g, b, a } ) {\n\tif ( a === 1 ) {\n\t\treturn {\n\t\t\ttype: 'rgb',\n\t\t\tvalue: [ r, g, b ],\n\t\t};\n\t}\n\treturn {\n\t\ttype: 'rgba',\n\t\tvalue: [ r, g, b, a ],\n\t};\n}\n\nexport function getGradientWithColorStopAdded( gradientAST, relativePosition, rgbaColor ) {\n\tconst colorStop = tinyColorRgbToGradientColorStop( rgbaColor );\n\tcolorStop.length = {\n\t\ttype: '%',\n\t\tvalue: relativePosition,\n\t};\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: [\n\t\t\t...gradientAST.colorStops,\n\t\t\tcolorStop,\n\t\t],\n\t};\n}\n\nexport function getGradientWithPositionAtIndexChanged( gradientAST, index, relativePosition ) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.map(\n\t\t\t( colorStop, colorStopIndex ) => {\n\t\t\t\tif ( colorStopIndex !== index ) {\n\t\t\t\t\treturn colorStop;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...colorStop,\n\t\t\t\t\tlength: {\n\t\t\t\t\t\t...colorStop.length,\n\t\t\t\t\t\tvalue: relativePosition,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t),\n\t};\n}\n\nexport function isControlPointOverlapping( gradientAST, position, initialIndex ) {\n\tconst initialPosition = parseInt( gradientAST.colorStops[ initialIndex ].length.value );\n\tconst minPosition = Math.min( initialPosition, position );\n\tconst maxPosition = Math.max( initialPosition, position );\n\n\treturn some(\n\t\tgradientAST.colorStops,\n\t\t( { length }, index ) => {\n\t\t\tconst itemPosition = parseInt( length.value );\n\t\t\treturn index !== initialIndex && (\n\t\t\t\tMath.abs( itemPosition - position ) < MINIMUM_DISTANCE_BETWEEN_POINTS ||\n\t\t\t\t( minPosition < itemPosition && itemPosition < maxPosition )\n\t\t\t);\n\t\t}\n\t);\n}\n\nfunction getGradientWithPositionAtIndexSummed( gradientAST, index, valueToSum ) {\n\tconst currentPosition = gradientAST.colorStops[ index ].length.value;\n\tconst newPosition = Math.max( 0, Math.min( 100, parseInt( currentPosition ) + valueToSum ) );\n\tif ( isControlPointOverlapping( gradientAST, newPosition, index ) ) {\n\t\treturn gradientAST;\n\t}\n\treturn getGradientWithPositionAtIndexChanged( gradientAST, index, newPosition );\n}\n\nexport function getGradientWithPositionAtIndexIncreased( gradientAST, index ) {\n\treturn getGradientWithPositionAtIndexSummed( gradientAST, index, MINIMUM_DISTANCE_BETWEEN_POINTS );\n}\n\nexport function getGradientWithPositionAtIndexDecreased( gradientAST, index ) {\n\treturn getGradientWithPositionAtIndexSummed( gradientAST, index, -MINIMUM_DISTANCE_BETWEEN_POINTS );\n}\n\nexport function getGradientWithColorAtIndexChanged( gradientAST, index, rgbaColor ) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.map(\n\t\t\t( colorStop, colorStopIndex ) => {\n\t\t\t\tif ( colorStopIndex !== index ) {\n\t\t\t\t\treturn colorStop;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...colorStop,\n\t\t\t\t\t...tinyColorRgbToGradientColorStop( rgbaColor ),\n\t\t\t\t};\n\t\t\t}\n\t\t),\n\t};\n}\n\nexport function getGradientWithColorAtPositionChanged( gradientAST, relativePositionValue, rgbaColor ) {\n\tconst index = findIndex( gradientAST.colorStops, ( colorStop ) => {\n\t\treturn (\n\t\t\tcolorStop &&\n\t\t\tcolorStop.length &&\n\t\t\tcolorStop.length.type === '%' &&\n\t\t\tcolorStop.length.value === relativePositionValue.toString()\n\t\t);\n\t} );\n\treturn getGradientWithColorAtIndexChanged( gradientAST, index, rgbaColor );\n}\n\nexport function getGradientWithControlPointRemoved( gradientAST, index ) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.filter( ( elem, elemIndex ) => {\n\t\t\treturn elemIndex !== index;\n\t\t} ),\n\t};\n}\n\nexport function getHorizontalRelativeGradientPosition( mouseXCoordinate, containerElement, positionedElementWidth ) {\n\tif ( ! containerElement ) {\n\t\treturn;\n\t}\n\tconst { x, width } = containerElement.getBoundingClientRect();\n\tconst absolutePositionValue = mouseXCoordinate - x - MINIMUM_ABSOLUTE_LEFT_POSITION - ( positionedElementWidth / 2 );\n\tconst availableWidth = width - MINIMUM_ABSOLUTE_LEFT_POSITION - INSERT_POINT_WIDTH;\n\treturn Math.round(\n\t\tMath.min( Math.max( ( absolutePositionValue * 100 ) / availableWidth, 0 ), 100 )\n\t);\n}\n\n/**\n * Returns the marker points from a gradient AST.\n *\n * @param {Object} gradientAST An object representing the gradient AST.\n *\n * @return {Array.<{color: string, position: string, positionValue: number}>}\n *         An array of markerPoint objects.\n *         color:         A string with the color code ready to be used in css style e.g: \"rgba( 1, 2 , 3, 0.5)\".\n *         position:      A string with the position ready to be used in css style e.g: \"70%\".\n *         positionValue: A number with the relative position value e.g: 70.\n */\nexport function getMarkerPoints( gradientAST ) {\n\tif ( ! gradientAST ) {\n\t\treturn [];\n\t}\n\treturn map( gradientAST.colorStops, ( colorStop ) => {\n\t\tif ( ! colorStop || ! colorStop.length || colorStop.length.type !== '%' ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tcolor: serializeGradientColor( colorStop ),\n\t\t\tposition: serializeGradientPosition( colorStop.length ),\n\t\t\tpositionValue: parseInt( colorStop.length.value ),\n\t\t};\n\t} );\n}\n"]}