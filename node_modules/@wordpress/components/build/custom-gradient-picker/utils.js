"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGradientWithColorStopAdded = getGradientWithColorStopAdded;
exports.getGradientWithPositionAtIndexChanged = getGradientWithPositionAtIndexChanged;
exports.isControlPointOverlapping = isControlPointOverlapping;
exports.getGradientWithPositionAtIndexIncreased = getGradientWithPositionAtIndexIncreased;
exports.getGradientWithPositionAtIndexDecreased = getGradientWithPositionAtIndexDecreased;
exports.getGradientWithColorAtIndexChanged = getGradientWithColorAtIndexChanged;
exports.getGradientWithColorAtPositionChanged = getGradientWithColorAtPositionChanged;
exports.getGradientWithControlPointRemoved = getGradientWithControlPointRemoved;
exports.getHorizontalRelativeGradientPosition = getHorizontalRelativeGradientPosition;
exports.getMarkerPoints = getMarkerPoints;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _lodash = require("lodash");

var _constants = require("./constants");

var _serializer = require("./serializer");

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */
function tinyColorRgbToGradientColorStop(_ref) {
  var r = _ref.r,
      g = _ref.g,
      b = _ref.b,
      a = _ref.a;

  if (a === 1) {
    return {
      type: 'rgb',
      value: [r, g, b]
    };
  }

  return {
    type: 'rgba',
    value: [r, g, b, a]
  };
}

function getGradientWithColorStopAdded(gradientAST, relativePosition, rgbaColor) {
  var colorStop = tinyColorRgbToGradientColorStop(rgbaColor);
  colorStop.length = {
    type: '%',
    value: relativePosition
  };
  return (0, _objectSpread2.default)({}, gradientAST, {
    colorStops: [].concat((0, _toConsumableArray2.default)(gradientAST.colorStops), [colorStop])
  });
}

function getGradientWithPositionAtIndexChanged(gradientAST, index, relativePosition) {
  return (0, _objectSpread2.default)({}, gradientAST, {
    colorStops: gradientAST.colorStops.map(function (colorStop, colorStopIndex) {
      if (colorStopIndex !== index) {
        return colorStop;
      }

      return (0, _objectSpread2.default)({}, colorStop, {
        length: (0, _objectSpread2.default)({}, colorStop.length, {
          value: relativePosition
        })
      });
    })
  });
}

function isControlPointOverlapping(gradientAST, position, initialIndex) {
  var initialPosition = parseInt(gradientAST.colorStops[initialIndex].length.value);
  var minPosition = Math.min(initialPosition, position);
  var maxPosition = Math.max(initialPosition, position);
  return (0, _lodash.some)(gradientAST.colorStops, function (_ref2, index) {
    var length = _ref2.length;
    var itemPosition = parseInt(length.value);
    return index !== initialIndex && (Math.abs(itemPosition - position) < _constants.MINIMUM_DISTANCE_BETWEEN_POINTS || minPosition < itemPosition && itemPosition < maxPosition);
  });
}

function getGradientWithPositionAtIndexSummed(gradientAST, index, valueToSum) {
  var currentPosition = gradientAST.colorStops[index].length.value;
  var newPosition = Math.max(0, Math.min(100, parseInt(currentPosition) + valueToSum));

  if (isControlPointOverlapping(gradientAST, newPosition, index)) {
    return gradientAST;
  }

  return getGradientWithPositionAtIndexChanged(gradientAST, index, newPosition);
}

function getGradientWithPositionAtIndexIncreased(gradientAST, index) {
  return getGradientWithPositionAtIndexSummed(gradientAST, index, _constants.MINIMUM_DISTANCE_BETWEEN_POINTS);
}

function getGradientWithPositionAtIndexDecreased(gradientAST, index) {
  return getGradientWithPositionAtIndexSummed(gradientAST, index, -_constants.MINIMUM_DISTANCE_BETWEEN_POINTS);
}

function getGradientWithColorAtIndexChanged(gradientAST, index, rgbaColor) {
  return (0, _objectSpread2.default)({}, gradientAST, {
    colorStops: gradientAST.colorStops.map(function (colorStop, colorStopIndex) {
      if (colorStopIndex !== index) {
        return colorStop;
      }

      return (0, _objectSpread2.default)({}, colorStop, tinyColorRgbToGradientColorStop(rgbaColor));
    })
  });
}

function getGradientWithColorAtPositionChanged(gradientAST, relativePositionValue, rgbaColor) {
  var index = (0, _lodash.findIndex)(gradientAST.colorStops, function (colorStop) {
    return colorStop && colorStop.length && colorStop.length.type === '%' && colorStop.length.value === relativePositionValue.toString();
  });
  return getGradientWithColorAtIndexChanged(gradientAST, index, rgbaColor);
}

function getGradientWithControlPointRemoved(gradientAST, index) {
  return (0, _objectSpread2.default)({}, gradientAST, {
    colorStops: gradientAST.colorStops.filter(function (elem, elemIndex) {
      return elemIndex !== index;
    })
  });
}

function getHorizontalRelativeGradientPosition(mouseXCoordinate, containerElement, positionedElementWidth) {
  if (!containerElement) {
    return;
  }

  var _containerElement$get = containerElement.getBoundingClientRect(),
      x = _containerElement$get.x,
      width = _containerElement$get.width;

  var absolutePositionValue = mouseXCoordinate - x - _constants.MINIMUM_ABSOLUTE_LEFT_POSITION - positionedElementWidth / 2;
  var availableWidth = width - _constants.MINIMUM_ABSOLUTE_LEFT_POSITION - _constants.INSERT_POINT_WIDTH;
  return Math.round(Math.min(Math.max(absolutePositionValue * 100 / availableWidth, 0), 100));
}
/**
 * Returns the marker points from a gradient AST.
 *
 * @param {Object} gradientAST An object representing the gradient AST.
 *
 * @return {Array.<{color: string, position: string, positionValue: number}>}
 *         An array of markerPoint objects.
 *         color:         A string with the color code ready to be used in css style e.g: "rgba( 1, 2 , 3, 0.5)".
 *         position:      A string with the position ready to be used in css style e.g: "70%".
 *         positionValue: A number with the relative position value e.g: 70.
 */


function getMarkerPoints(gradientAST) {
  if (!gradientAST) {
    return [];
  }

  return (0, _lodash.map)(gradientAST.colorStops, function (colorStop) {
    if (!colorStop || !colorStop.length || colorStop.length.type !== '%') {
      return null;
    }

    return {
      color: (0, _serializer.serializeGradientColor)(colorStop),
      position: (0, _serializer.serializeGradientPosition)(colorStop.length),
      positionValue: parseInt(colorStop.length.value)
    };
  });
}
//# sourceMappingURL=utils.js.map